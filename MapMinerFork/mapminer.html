<!DOCTYPE html>
<meta charset="utf-8">

<body>
	<script src="data.js"></script>
	<script src="https://d3js.org/d3.v7.js"></script>

	<!-- Range slider code -->
	<script src="d3slider.js"></script>

	<!-- Range slider style -->
	<link href="d3slider.css" rel="stylesheet">

	<style type="text/css">
		#slider-container {
			position: relative;
			height: 30px;
			background-color: #eeeef5;
		}
	</style>

	<title>Map</title>

	<p id="value"></p>

	<div id="slider-container"></div>
	<div id="range-label"></div>

	<div id="map"></div>

	<div id="input"></div>

	<script>
		// Initial Values
		const SCALE = 2
		let width = 417 * SCALE, height = 417 * SCALE; // 417 is image size
		const CENTER = { x: width / 2, y: height / 2 };




		// console.log(_jsondata)


		// console.log(_jsondata.timeline);

		// jsondata = objFilter(_jsondata.timeline, { event: "PlayerLocationEvent", player: -1982006789 });

		// var slider = d3
		// 	.sliderHorizontal()
		// 	.min(0)
		// 	.max(10)
		// 	.step(1)
		// 	.width(300)
		// 	.displayValue(false)
		// 	.on('onchange', (val) => {
		// 		d3.select('#value').text(val);
		// 	});

		// d3.select('#slider')
		// 	.append('svg')
		// 	.attr('width', 500)
		// 	.attr('height', 100)
		// 	.append('g')
		// 	.attr('transform', 'translate(30,30)')
		// 	.call(slider);

		// prob not the best way to do this but it works
		function generateData(data, lowerTime, upperTime) {
			let _data = {}
			let colors = ["red", "green", "blue", "orange", "purple", "yellow", "cyan", "black"];
			for (const [key, value] of Object.entries(data)) {
				// console.log(`${key}: ${value}`);

				let res = value.filter(f => f.event === "PlayerLocationEvent") // && f.player === -1982006789
				if (res.length > 0) {
					// jsondata[f].push(...res)
					res.forEach(r => {
						// console.log(Math.floor(r.time / 1000), lowerTime, upperTime, Math.floor(r.time / 1000) >= lowerTime && Math.floor(r.time / 1000) <= upperTime)
						if (Math.floor(r.time / 1000) >= lowerTime && Math.floor(r.time / 1000) <= upperTime) {
							console.log(r.time)
							if (r.player in _data) {
								_data[r.player].pos.push(r)
							}
							else {
								_data[r.player] = { player: r.player, color: colors.shift(), pos: [r] }
							}
						}

					});
				}
			}
			for (const [key, value] of Object.entries(_data)) {
				_data[key].pos = _data[key].pos.map(p => coord(p.x, p.z))
			}

			return _data;
		}

		let jsondata = generateData(_jsondata.timeline, _jsondata.time.min, _jsondata.time.max)


		console.log(jsondata)

		var slider = createD3RangeSlider(_jsondata.time.min, _jsondata.time.max, "#slider-container", true);

		slider.onChangeEnd(function (newRange) {

			console.log(newRange);
			let data = generateData(_jsondata.timeline, newRange.begin, newRange.end)

			console.log(data)

			drawPlayers(data)


			d3.select("#range-label").html(newRange.begin + " &mdash; " + newRange.end);
		});

		let input = d3.select("div#input")

		input.append("h3")
			.text("Toggle Visibility of player")
		input.append("p")
			.text("rises to top on reshowing")

		// Select map div and set attributes
		let map = d3.select("div#map")
			.style("width", width + "px")
			.style("height", height + "px")

		// create base svg
		let _svg = map
			.append("svg")
			.style("width", width + "px")
			.style("height", height + "px")
		let svg = _svg.append("g")

		// add image to svg
		let image = svg.append("image")
			.attr("width", width + "px")
			.attr("height", height + "px")
			.attr("xlink:href", "highresmap.png")

		let heatmap = svg.append("g").attr("id", 'heatmap')

		// handle pan and zoom of svg
		let zoom = d3.zoom()
			.translateExtent([[0, 0], [width, height]])
			.scaleExtent([1, 5])
			.on('zoom', handleZoom);

		// create group <g id={id}> for each player in data
		// draw path for each player with unique color
		function drawPlayers(data) {

			console.log('draw players', data)

			let path = heatmap
				.selectAll("path")
				.data(Object.values(data))
			// .enter()
			// // .append("g")
			// .append("path")
			// .attr("id", function (d) { return d.player })
			// .attr("d", function (d) { return d3.line()(d.pos) })
			// // .attr("stroke", "black")
			// .attr("fill", "none")
			// .attr("stroke", function (d) { return d.color })
			// .attr("visibility", "visible")
			// .exit().attr("visibility", "hidden")

			console.log(path)

			path.enter().append("path")//.attr("id", function (d) { return d.player })
				.attr("id", function (d) { return d.player })
				.attr("stroke", function (d) { return d.color })
				.attr("fill", "none")
				.attr("visibility", "visible")

			path
				.attr("d", function (d) {
					console.log(d.pos, d3.line()(d.pos))
					return d3.line()(d.pos)
				})
				.attr("visibility", "visible")

			path.exit().attr("visibility", "hidden")


			return path



			// x.enter()
			// 	// .append("g")
			// 	.append("path")
			// 	.attr("id", function (d) { return d.player })
			// 	.attr("d", function (d) { return d3.line()(d.pos) })
			// 	// .attr("stroke", "black")
			// 	.attr("fill", "none")
			// 	.attr("stroke", function (d) { return d.color })
			// 	.attr("visibility", "visible")

			// x.update()
			// 	.select("path")
			// 	.attr("d", function (d) { return d3.line()(d.pos) })

			// x.exit().remove()
		}
		let players = drawPlayers(jsondata)
		// .call(createButton, function (d) { return d }, null)
		// .select("#input")
		// .append("button")

		// console.log(players)

		players.each(function (player, i) {
			console.log("p: " + player, "i: " + i);
			// player.append("g")
			d3.select(this).call(createButton, this, player, function (d) { return d })
		});

		//<label for="quantity">Quantity:</label>
		function createButton(selection, player, d) {
			// console.log('create button', selection, d)
			// selection.append("g")
			input.append("input")
				.attr("type", "checkbox")
				.attr("name", d.player)
				.attr("value", d.player)
				.property("checked", true)
				.on("click", function () {
					let button = d3.select(this);
					let state = button.property("checked");
					selection.attr("visibility", state ? "visible" : "hidden")
					if (state) {
						// button.raise()	// need to move label and </br> as well
						selection.raise()
					}
				})
			input.append("label")
				.attr("for", d.player)
				.text(d.player)
				.style("color", d.color)
			input.append("br")
		}

		function initZoom() {
			// d3.select('svg')
			svg.call(zoom);
		}

		function coord(x, y) {
			return [Math.floor(x * SCALE + CENTER.x), Math.floor(y * SCALE + CENTER.y)]
		}



		function handleZoom(e) {
			// let transform = { k: Math.round(e.transform.k), x: Math.round(e.transform.x), y: Math.round(e.transform.y) }
			// e.transform.k = Math.round(e.transform.k)
			// e.transform.x = e.transform.x * e.transform.k
			// e.transform.y = e.transform.y * e.transform.k

			// console.log(e.transform)
			// console.log(e.transform, transform)

			// d3.select('svg g')
			svg.attr('transform', e.transform);
		}

		initZoom();
	</script>
</body>