<!DOCTYPE html>
<meta charset="utf-8">

<body>
	<script src="data.js"></script>
	<script src="https://d3js.org/d3.v7.js"></script>

	<!-- Range slider code -->
	<script src="d3slider.js"></script>

	<!-- Range slider style -->
	<link href="d3slider.css" rel="stylesheet">

	<style type="text/css">
		#slider-container {
			position: relative;
			height: 30px;
			background-color: #eeeef5;
		}
	</style>

	<title>Map</title>

	<p id="value"></p>

	<div id="slider-container"></div>
	<div id="range-label"></div>

	<div id="map"></div>

	<div id="input"></div>

	<script>
		// Initial Values
		const SCALE = 2
		let width = 417 * SCALE, height = 417 * SCALE; // 417 is image size
		const CENTER = { x: width / 2, y: height / 2 };
		let colors = ["red", "green", "blue", "orange", "purple", "yellow", "cyan", "black"];


		let inputdata = _jsondata;

		const _minTime = inputdata.time.min;
		const _maxTime = inputdata.time.max;

		let data = {};
		let dataMin = _minTime;
		let dataMax = _maxTime;




		// prob not the best way to do this but it works
		for (const [key, value] of Object.entries(inputdata.timeline)) {
			let res = value.filter(f => f.event === "PlayerLocationEvent")
			if (res.length > 0) {
				res.forEach(r => {
					if (Math.floor(r.time / 1000) >= _minTime && Math.floor(r.time / 1000) <= _maxTime) {

						console.log(r, r.pos)

						if (r.player in data) {
							data[r.player].pos.push(coord(r.x, r.z))
						}
						else {
							data[r.player] = { player: r.player, color: colors.shift(), pos: [coord(r.x, r.z)] } //, pos: coord(r.x, r.z)
							// data[r.player].pos.push(coord(r.x, r.z))

						}
					}

				});
			}
		}
		// for (const [key, value] of Object.entries(_data)) {
		// 	_data[key].pos = _data[key].pos.map(p => coord(p.x, p.z))
		// }


		function generateData(lowerTime, upperTime) {
			if (lowerTime == dataMin && upperTime == dataMax) {
				return;
			}

			console.log('a')
			// Object.keys(data).forEach(player => {
			// 	data[player].pos = [];
			// 	console.log(player, data[player]);
			// })

			for (const player in data) {
				data[player].pos.length = 0;
				console.log(player, data[player]);
			}

			console.log('b')

			console.log(data);

			console.log('c')


			console.log(Object.entries(inputdata.timeline))

			for (const [key, value] of Object.entries(inputdata.timeline)) {
				let res = value.filter(f => f.event === "PlayerLocationEvent")
				if (res.length > 0) {
					res.forEach(r => {
						if (Math.floor(r.time / 1000) >= _minTime && Math.floor(r.time / 1000) <= _maxTime) {
							if (r.player in data) {
								data[r.player].pos.push(coord(r.x, r.z))
							}
							else {
								data[r.player] = { player: r.player, color: colors.shift(), pos: [coord(r.x, r.z)] }
							}
						}

					});
				}
			}

			// return _data;
		}


		// let jsondata = data


		// console.log(jsondata)

		var slider = createD3RangeSlider(_jsondata.time.min, _jsondata.time.max, "#slider-container", true);

		slider.onChangeEnd(function (newRange) {

			console.log(newRange);
			// let data = 
			generateData(newRange.begin, newRange.end)

			console.log(data)

			drawPlayers(data)


			d3.select("#range-label").html(newRange.begin + " &mdash; " + newRange.end);
		});

		let input = d3.select("div#input")

		input.append("h3")
			.text("Toggle Visibility of player")
		input.append("p")
			.text("rises to top on reshowing")

		// Select map div and set attributes
		let map = d3.select("div#map")
			.style("width", width + "px")
			.style("height", height + "px")

		// create base svg
		let _svg = map
			.append("svg")
			.style("width", width + "px")
			.style("height", height + "px")
		let svg = _svg.append("g")

		// add image to svg
		let image = svg.append("image")
			.attr("width", width + "px")
			.attr("height", height + "px")
			.attr("xlink:href", "highresmap.png")

		let heatmap = svg.append("g").attr("id", 'heatmap')

		// handle pan and zoom of svg
		let zoom = d3.zoom()
			.translateExtent([[0, 0], [width, height]])
			.scaleExtent([1, 5])
			.on('zoom', handleZoom);

		// create group <g id={id}> for each player in data
		// draw path for each player with unique color
		function drawPlayers(data) {

			console.log('draw players', data, Object.values(data), Object.values(data))

			let path = heatmap
				.selectAll("path")
				.data(Object.values(data))
			// .enter()
			// // .append("g")
			// .append("path")
			// .attr("id", function (d) { return d.player })
			// .attr("d", function (d) { return d3.line()(d.pos) })
			// // .attr("stroke", "black")
			// .attr("fill", "none")
			// .attr("stroke", function (d) { return d.color })
			// .attr("visibility", "visible")
			// .exit().attr("visibility", "hidden")

			console.log(path)

			path.enter().append("path")//.attr("id", function (d) { return d.player })
				.attr("id", function (d) { return d.player })
				.attr("stroke", function (d) { return d.color })
				.attr("fill", "none")
				.attr("visibility", "visible")
				.attr("d", function (d) {
					// console.log(d.pos, d3.line()(d.pos))
					return d3.line()(d.pos)
				})

			path
				.attr("visibility", "visible")
				.attr("d", function (d) {
					// console.log(d.pos, d3.line()(d.pos))
					return d3.line()(d.pos)
				})

			path.exit().attr("visibility", "hidden")


			return path



			// x.enter()
			// 	// .append("g")
			// 	.append("path")
			// 	.attr("id", function (d) { return d.player })
			// 	.attr("d", function (d) { return d3.line()(d.pos) })
			// 	// .attr("stroke", "black")
			// 	.attr("fill", "none")
			// 	.attr("stroke", function (d) { return d.color })
			// 	.attr("visibility", "visible")

			// x.update()
			// 	.select("path")
			// 	.attr("d", function (d) { return d3.line()(d.pos) })

			// x.exit().remove()
		}
		let players = drawPlayers(data)
		// .call(createButton, function (d) { return d }, null)
		// .select("#input")
		// .append("button")

		// console.log(players)

		players.each(function (player, i) {
			console.log("p: " + player, "i: " + i);
			// player.append("g")
			d3.select(this).call(createButton, this, player, function (d) { return d })
		});

		//<label for="quantity">Quantity:</label>
		function createButton(selection, player, d) {
			// console.log('create button', selection, d)
			// selection.append("g")
			input.append("input")
				.attr("type", "checkbox")
				.attr("name", d.player)
				.attr("value", d.player)
				.property("checked", true)
				.on("click", function () {
					let button = d3.select(this);
					let state = button.property("checked");
					selection.attr("visibility", state ? "visible" : "hidden")
					if (state) {
						// button.raise()	// need to move label and </br> as well
						selection.raise()
					}
				})
			input.append("label")
				.attr("for", d.player)
				.text(d.player)
				.style("color", d.color)
			input.append("br")
		}

		function initZoom() {
			// d3.select('svg')
			svg.call(zoom);
		}

		function coord(x, y) {
			return [Math.floor(x * SCALE + CENTER.x), Math.floor(y * SCALE + CENTER.y)]
		}



		function handleZoom(e) {
			// let transform = { k: Math.round(e.transform.k), x: Math.round(e.transform.x), y: Math.round(e.transform.y) }
			// e.transform.k = Math.round(e.transform.k)
			// e.transform.x = e.transform.x * e.transform.k
			// e.transform.y = e.transform.y * e.transform.k

			// console.log(e.transform)
			// console.log(e.transform, transform)

			// d3.select('svg g')
			svg.attr('transform', e.transform);
		}

		initZoom();
	</script>
</body>